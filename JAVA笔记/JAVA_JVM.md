# GC垃圾收集机制

HotSpot中判断是否是垃圾对象是通过**可达性算法**，从CG Root开始可达性判断，是否被引用。

## GC Root

CG Root可以包含以下对象:

1、虚拟机栈（栈中的本地变量表）中引用的对象；

2、方法区中类静态属性引用的对象；

3、方法区中常量引用的对象；

4、本地方法栈中JNI（即一般说的Native方法）引用的对象。

## 内存回收算法

### 一、 标记／清除算法

内存中的对象构成一棵树，当有效的内存被耗尽的时候，程序就会停止，做两件事，第一：标记，标记从树根可达的对象（途中水红色），第二：清除（清楚不可达的对象）。标记清除的时候有停止程序运行，如果不停止，此时如果存在新产生的对象，这个对象是树根可达的，但是没有被标记（标记已经完成了），会清除掉。

![](C:\Users\XIONG\Pictures\IT\JAVA\JVM\GC_标记清除.png)

**缺点**：递归效率低性能低；释放空间不连续容易导致内存碎片；会停止整个程序运行；

### 二、 复制算法

把内存分成两块区域：空闲区域和活动区域，第一还是标记（标记谁是可达的对象），标记之后把可达的对象复制到空闲区，将空闲区变成活动区，同时把以前活动区对象1，4清除掉，变成空闲区。

![](C:\Users\XIONG\Pictures\IT\JAVA\JVM\GC_标记复制.png)

**缺点**：速度快但耗费空间，假定活动区域全部是活动对象，这个时候进行交换的时候就相当于多占用了一倍空间，但是没啥用。

### **三、 标记整理算法**

标记谁是活跃对象，整理，会把内存对象整理成一课树一个连续的空间

![](C:\Users\XIONG\Pictures\IT\JAVA\JVM\GC_标记整理.png)

1， 分代GC在新生代的算法：采用了GC的复制算法，速度快，因为新生代一般是新对象，都是瞬态的用了可能很快被释放的对象。

2， 分代GC在年老代的算法 标记／整理算法，GC后会执行压缩，整理到一个连续的空间，这样就维护着下一次分配对象的指针，下一次对象分配就可以采用碰撞指针技术，将新对象分配在第一个空闲的区域。

