# JAVA

- 方法的参数加上final修饰 👌

**基本数据类型**防止值被改变，方法中如果对该形参进行修改，**会编译不通过**。如果是**对象引用**，防止引用被修改。

- Properties
- 注解与AOP
- java日志系统
- 数据库分页
- 数据库连接池
- google guava
- jodd工具
- 注解
- 「import static」静态导入 👌

使得不用“ClassName.xxx”写具体的类来静态导入

- dubbo
- MessageFormat
- multi-catch 👌

语法糖，异常类不能是继承关系

```java
catch(IOException | ClassNotFoundException e){
}
```

- java线程池

  - Google Guava 的ListeningExecutorService 线程池，为Callable添加回调方法callBack

    ```java
    ListeningExecutorService executorService = MoreExecutors.listeningDecorator(threadPoolExecutor); 
    ListenableFuture listenableFuture = executorService.submit(myCallable);
    //回调函数
    Futures.addCallback(listenableFuture, new FutureCallback<T>() {
                    //任务处理成功时执行
                    @Override
                    public void onSuccess(T t) {}
                    //任务处理失败时执行
                    @Override
                    public void onFailure(Throwable throwable) {
                   	System.out.println("处理失败："+throwable);}},executorService);
    
    ```

    

- Vert.x框架

- spring 定时

- Callable

- AtomicInteger



# 系统

- 日志系统 👌

  1. **日志接口(slf4j)**
    slf4j是对所有日志框架制定的一种规范、标准、接口，并**不是一个框架的具体的实现**，因为接口并不能独立使用，需要和具体的日志框架实现配合使用（如log4j、logback）
  2. **日志实现(log4j、logback、log4j2)**
    log4j是apache实现的一个开源日志组件，logback同样是由log4j的作者设计完成的，拥有更好的特性，用来取代log4j的一个日志框架，是slf4j的原生实现，Log4j2是log4j 1.x和logback的改进版，据说采用了一些新技术（无锁异步、等等），使得日志的吞吐量、性能比log4j 1.x提高10倍，并解决了一些死锁的bug，而且配置更加简单灵活。
  3. **为什么需要日志接口，直接使用具体的实现不就行了吗？**
    接口用于定制规范，可以有多个实现，使用时是面向接口的（导入的包都是slf4j的包而不是具体某个日志框架中的包），即直接和接口交互，不直接使用实现，所以可以任意的更换实现而不用更改代码中的日志相关代码。比如：slf4j定义了一套日志接口，项目中使用的日志框架是logback，开发中调用的所有接口都是slf4j的，不直接使用logback，调用是 自己的工程调用slf4j的接口，slf4j的接口去调用logback的实现，可以看到整个过程应用程序并没有直接使用logback，当项目需要更换更加优秀的日志框架时（如log4j2）只需要引入Log4j2的jar和Log4j2对应的配置文件即可，完全不用更改Java代码中的日志相关的代码logger.info(“xxx”)，也不用修改日志相关的类的导入的包（import org.slf4j.Logger;import org.slf4j.LoggerFactory;
- 批处理 spring-batch
- 分布式追踪系统APM工具
- 


# 符号

| 符号 | 意思    |
| ---- | ------- |
| 👌    | 已完成  |
| ✏️    | 编辑ing |