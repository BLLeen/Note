# JAVA

- 方法的参数加上final修饰 👌

**基本数据类型**防止值被改变，方法中如果对该形参进行修改，**会编译不通过**。如果是**对象引用**，防止引用被修改。

- Properties

  - java自带的Properties类读取.properties文件

  读取路径上的.properties文件（因为properties文件是行一个键值，所以对IO读是行读取的），生成键值对。

  - Spring的读取properties

  

- 注解与AOP 👌

  - 注解

  注解通过反射getAnnotation()获取注解，然后具体要如何对标注目标进行具体操作。

  - Spring AOP

  Spring自身有实现AOP，Spring也有spring-aspects依赖包，使用了aspectj的**语法**，并不是使用aspectj实现AOP。

Spring AOP类与目标类都必须是bean才能生效。对应@Around环绕通知，需要使用ProceedingJoinPoint.procee()来运行目标类方法，如果需要返回值，需要与功能方法返回值一致。

```java

/**
* 代理类
**/
@Aspect
@Service
public class MyAnnotationAspect {
 @Pointcut("@annotation(com.xiong.aopdemo.annotation.MyAnnotation)")
    public void DebugTraceMethod() {}
    @Before("DebugTraceMethod()")
    public void beforeDebugTraceMethod(JoinPoint joinPoint) {
        System.out.println("before");
    }
    @After("DebugTraceMethod()")
    public void afterDebugTraceMethod(JoinPoint joinPoint){
        System.out.println("after");
    }
    @Around("DebugTraceMethod()")
    public Integer aroundDebugTraceMethod(ProceedingJoinPoint pjp)throws Throwable {
        System.out.println("around----start");
        Integer r = (Integer) pjp.proceed();
        System.out.println("around----end");
      
      //返回值与目标方法的返回值一致
        return r;
    }
}
/**
* 目标类
**/
@Service
public class TestDemo {
    @MyAnnotation(value = "hello")
    public Integer printWord(){
        int i=0;
        System.out.println("hello");
        return ++i;
    }
}
```

- java日志系统
- 数据库分页
- 数据库连接池
- google guava
- jodd工具
- 注解
- 「import static」静态导入 👌

使得不用“ClassName.xxx”写具体的类来静态导入

- dubbo
- MessageFormat
- multi-catch 👌

语法糖，异常类不能是继承关系

```java
catch(IOException | ClassNotFoundException e){
}
```

- java线程池 ✏️

  - **ExecutorService**  真正的线程池接口。

  - **ThreadPoolExecutor** ExecutorService的实现类

  - [Java四种线程池使用](https://blog.csdn.net/achuo/article/details/80623893)

  - **Google Guava** 的**ListeningExecutorService**线程池，为Callable添加**回调方法**callBack

    ```java
    ListeningExecutorService executorService = MoreExecutors.listeningDecorator(threadPoolExecutor); 
    ListenableFuture listenableFuture = executorService.submit(myCallable);
    //回调函数
    Futures.addCallback(listenableFuture, new FutureCallback<T>() {
                    //任务处理成功时执行
                    @Override
                    public void onSuccess(T t) {}
                    //任务处理失败时执行
                    @Override
                    public void onFailure(Throwable throwable) {
                   	System.out.println("处理失败："+throwable);}},executorService);
    ```

    

  - 线程池四种拒绝任务策略

    

- 线程 ✏️

  - Runnable接口
  - Thread类，这个类也是继承了Runnable接口
  - Callable接口

- Vert.x框架

- spring 定时

- AtomicInteger 

- Spring

- 什么时候使用**protected**修饰符 👌

protected修饰符的成员**不能被外部包访问**，这样做的目的是为了能被继承而保证其内部成员不被随意调用。比如一些带有**生命周期方法**（onDestroy(),onCreate()）的类，这些方法不希望被外部调用，但是需要被子类访问。

- synchronized
- 



# 系统

- 日志系统 👌

  1. **日志接口(slf4j、common.logging)**
      slf4j是对所有日志框架制定的一种规范、标准、接口，并**不是一个框架的具体的实现**，因为接口并不能独立使用，需要和具体的日志框架实现配合使用（如log4j、logback）
  2. **日志实现(log4j、logback、log4j2)**
      log4j是apache实现的一个开源日志组件，logback同样是由log4j的作者设计完成的，拥有更好的特性，用来取代log4j的一个日志框架，是slf4j的原生实现，Log4j2是log4j 1.x和logback的改进版，据说采用了一些新技术（无锁异步、等等），使得日志的吞吐量、性能比log4j 1.x提高10倍，并解决了一些死锁的bug，而且配置更加简单灵活。
  3. **为什么需要日志接口，直接使用具体的实现不就行了吗？**
      接口用于定制规范，可以有多个实现，使用时是面向接口的（导入的包都是slf4j的包而不是具体某个日志框架中的包），即直接和接口交互，不直接使用实现，所以可以任意的更换实现而不用更改代码中的日志相关代码。比如：slf4j定义了一套日志接口，项目中使用的日志框架是logback，开发中调用的所有接口都是slf4j的，不直接使用logback，调用是 自己的工程调用slf4j的接口，slf4j的接口去调用logback的实现，可以看到整个过程应用程序并没有直接使用logback，当项目需要更换更加优秀的日志框架时（如log4j2）只需要引入Log4j2的jar和Log4j2对应的配置文件即可，完全不用更改Java代码中的日志相关的代码logger.info(“xxx”)，也不用修改日志相关的类的导入的包（import org.slf4j.Logger;import org.slf4j.LoggerFactory;
- 批处理 spring-batch
- 分布式追踪系统APM工具
- SQL
  - interval


# 符号

| 符号 | 意思    |
| ---- | ------- |
| 👌    | 已完成  |
| ✏️    | 编辑ing |