# 杂记
- 对于函数，花括号必须和函数名同一行

```go
func function() {

}
```
- 当标识符(包括常量、变量、类型、函数名、结构字段等等)以一个 **大写字母开头**，类似 **public**，可以被外部包的代码所使用(客户端程序需要先导入这个包)，标识符如果以**小写字母开头**，则对包外是不可见的(类似 **protected**)。
- 一行代表一个语句，多个语句写在同一行需要使用;隔开

# 关键字

## var && const
**var** 定义变量
> var 变量名[ , 变量名2 , 变量名3 ] 数据类型
<br>var 变量名[ , 变量名2 , 变量名3 ] 数据类型 = value[ ,v2 , v3]
<br>var 变量名 = value  //根据数值自动判断数据类型
<br>var ( 定义1 , 定义2 )  //定义多个不同类型的变量

对于局部变量可以使用 **简短声明**
<br> 变量名[ , 变量名2 , 变量名3 ] := value[ ,v2 , v3]

**const** 定义常量 
<br> 用法与var类似，初始化后不可修改

## package && import

**package** 定义包

**import** 引入包
```go
import (
    "fmt" //常规引入
    "shorturl/model"  // 加载 GOPATH/src/shorturl/model 模块
    . "fmt" //使用时可以省略(fmt.)Println()
    f "fmt" //别名，使用时可以使用f.Println()
    _ "fmt" //Golang不允许不使用导入的包，如果只是为了使用包内的init()使用该方式
)
```
## func
**func**定义函数

Go函数不支持嵌套、重载和默认参数

但支持以下特性：

1. 无需声明原型
2. 不定长度变参
3. 多返回值
4. 命名返回值参数
5. 匿名函数
6. 闭包


```go
func A(a int, b string) (int, string, int)  { 
    //第一个括号当中是参数列表，第二个括号是返回值列表
    
}
func A(a, b, c int) (int, string, int)  {
    //如果abc都是int型的话，可以按照这种方法进行简写，同样的方法也适用于返回值当中

}
func A() (a, b, c int)  { 
    //如果这样写的话就必须要命名返回值
    //命名返回值和不命名返回值得区别
}
func A() (int, int, int)  { 
    a, b, c := 1,2,3
    return a,b,c
    //如果此时没有命名返回值的时候，那么在返回值得时候就必须写上return a,b,c
    //当然为了代码的可读性，这里我们规定必须return 的时候加上返回值名
}
```
## 不定长变参
参数列表的**最后一个参数**可以是不定长变参
```go
func A(a ...int) {
    //这里传进来的实际上是一个slice,引用类型
    a[0] = 3
    a[1] = 4
    //尽管我们在函数A当中接收到的是一个slice，但是它得到的是一个值拷贝
    //和直接传递一个slice的区别看函数B
    fmt.Println(a)
}
func B(s []int)  {
    //这里并不是传递一个指针进去，而是对这个slice的内存地址进行了一个拷贝
    //这里还可以看到像int型、string型进行常规的参数传进去的话，只是进行了个值拷贝，slice传进去虽然也是拷贝，但是它是内存地址的拷贝
    s[0] = 4
    s[1] = 5
    s[2] = 6
    s[3] = 7
    fmt.Println(s)
    //在这里 我们看到我们在函数B当中的修改，实际上影响到了我们main函数当中的变量s1
    //如果直接传递一个slice，它的修改就会影响到这个slice的本身

}
```
## 匿名函数
```go
func main() {
    a := func() {
        //此时这个代码块就是一个匿名函数，这个函数本身没有名称，我们将她赋值给a，然后调用
        fmt.Println("Func A")

    }
    a() //依然可以打印func A
}
```
## 函数类型
```go
func main() {
    a := A
    a() //这个时候是将A的函数类型赋值给a，在go语言当中一切皆是类型啊

}
func A() {
    fmt.Println("Func A")
}
```
## 