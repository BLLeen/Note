# 工厂模式

1简单工厂模式、工厂模式和抽象工厂模式
三种工厂模式从左到右逐步抽象，并且更具一般性。简单工厂模式可以看做工厂模式的一种简单化，可以归为工厂模式的一种我们先来看看简单工厂模式

## 简单工厂模式
实现类 实现类对象= 工厂类.静态成员方法(实现类信息);
1. 创建接口或抽象类 //供实现类(产品)继承或实现
2. 创建实现类 //继承与接口或抽象类
3. 创建工厂类，静态成员方法用来获取产品形象，并返回实现类对象

```
步骤 1
创建一个接口:

Shape.java
public interface Shape {
   void draw();
}
步骤 2
创建实现接口的实体类。

Rectangle.java
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
Square.java
public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
Circle.java
public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
步骤 3
创建一个工厂，生成基于给定信息的实体类的对象。

ShapeFactory.java
public class ShapeFactory {
    
   //使用 getShape 方法获取形状类型的对象
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
}
步骤 4
使用该工厂，通过传递类型信息来获取实体类的对象。

FactoryPatternDemo.java
public class FactoryPatternDemo {
 
   public static void main(String[] args) {
      ShapeFactory shapeFactory = new ShapeFactory();
 
      //获取 Circle 的对象，并调用它的 draw 方法
      Shape shape1 = shapeFactory.getShape("CIRCLE");
 
      //调用 Circle 的 draw 方法
      shape1.draw();
 
      //获取 Rectangle 的对象，并调用它的 draw 方法
      Shape shape2 = shapeFactory.getShape("RECTANGLE");
 
      //调用 Rectangle 的 draw 方法
      shape2.draw();
 
      //获取 Square 的对象，并调用它的 draw 方法
      Shape shape3 = shapeFactory.getShape("SQUARE");
 
      //调用 Square 的 draw 方法
      shape3.draw();
   }
}
步骤 5
执行程序，输出结果：

Inside Circle::draw() method.
Inside Rectangle::draw() method.
Inside Square::draw() method.
```

优点：能够快速的生产某种制品。
缺点：当增加一种产品时，工厂只能修改自己的内部代码来生产这个产品，违反了开闭原则。于是，我们引出工厂方法模式。


## 抽象工厂模式

- 抽象工厂类，供工厂类，继承以获取该实现类的信息
- 工厂创造器/生成器类，以抽象工厂为成员方法返回值，获取抽象工厂子类-工厂类
- 工厂类，继承于工厂类，重写工厂类函数的抽象函数来获取生成实现类对象的信息
- 实现类

实现类 = 工厂生成器类.静态成员方法(工厂).静态成员方法(实现类信息)
```
步骤 1
为形状创建一个接口。

Shape.java
public interface Shape {
   void draw();
}
步骤 2
创建实现接口的实体类。

Rectangle.java

Rectangle.java
public class Rectangle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Rectangle::draw() method.");
   }
}
Square.java
public class Square implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Square::draw() method.");
   }
}
Circle.java
public class Circle implements Shape {
 
   @Override
   public void draw() {
      System.out.println("Inside Circle::draw() method.");
   }
}
步骤 3
为颜色创建一个接口。

Color.java
public interface Color {
   void fill();
}
步骤4
创建实现接口的实体类。

Red.java
public class Red implements Color {
 
   @Override
   public void fill() {
      System.out.println("Inside Red::fill() method.");
   }
}
Green.java
public class Green implements Color {
 
   @Override
   public void fill() {
      System.out.println("Inside Green::fill() method.");
   }
}
Blue.java
public class Blue implements Color {
 
   @Override
   public void fill() {
      System.out.println("Inside Blue::fill() method.");
   }
}
步骤 5
为 Color 和 Shape 对象创建抽象类来获取工厂。

AbstractFactory.java
public abstract class AbstractFactory {
   public abstract Color getColor(String color);
   public abstract Shape getShape(String shape) ;
}
步骤 6
创建扩展了 AbstractFactory 的工厂类，基于给定的信息生成实体类的对象。

ShapeFactory.java
public class ShapeFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      if(shapeType == null){
         return null;
      }        
      if(shapeType.equalsIgnoreCase("CIRCLE")){
         return new Circle();
      } else if(shapeType.equalsIgnoreCase("RECTANGLE")){
         return new Rectangle();
      } else if(shapeType.equalsIgnoreCase("SQUARE")){
         return new Square();
      }
      return null;
   }
   
   @Override
   public Color getColor(String color) {
      return null;
   }
}
ColorFactory.java
public class ColorFactory extends AbstractFactory {
    
   @Override
   public Shape getShape(String shapeType){
      return null;
   }
   
   @Override
   Color getColor(String color) {
      if(color == null){
         return null;
      }        
      if(color.equalsIgnoreCase("RED")){
         return new Red();
      } else if(color.equalsIgnoreCase("GREEN")){
         return new Green();
      } else if(color.equalsIgnoreCase("BLUE")){
         return new Blue();
      }
      return null;
   }
}
步骤 7
创建一个工厂创造器/生成器类，通过传递形状或颜色信息来获取工厂。

FactoryProducer.java
public class FactoryProducer {
   public static AbstractFactory getFactory(String choice){
      if(choice.equalsIgnoreCase("SHAPE")){
         return new ShapeFactory();
      } else if(choice.equalsIgnoreCase("COLOR")){
         return new ColorFactory();
      }
      return null;
   }
}
步骤 8
使用 FactoryProducer 来获取 AbstractFactory，通过传递类型信息来获取实体类的对象。

AbstractFactoryPatternDemo.java
public class AbstractFactoryPatternDemo {
   public static void main(String[] args) {
 
      //获取形状工厂
      AbstractFactory shapeFactory = FactoryProducer.getFactory("SHAPE");
 
      //获取形状为 Circle 的对象
      Shape shape1 = shapeFactory.getShape("CIRCLE");
 
      //调用 Circle 的 draw 方法
      shape1.draw();
 
      //获取形状为 Rectangle 的对象
      Shape shape2 = shapeFactory.getShape("RECTANGLE");
 
      //调用 Rectangle 的 draw 方法
      shape2.draw();
      
      //获取形状为 Square 的对象
      Shape shape3 = shapeFactory.getShape("SQUARE");
 
      //调用 Square 的 draw 方法
      shape3.draw();
 
      //获取颜色工厂
      AbstractFactory colorFactory = FactoryProducer.getFactory("COLOR");
 
      //获取颜色为 Red 的对象
      Color color1 = colorFactory.getColor("RED");
 
      //调用 Red 的 fill 方法
      color1.fill();
 
      //获取颜色为 Green 的对象
      Color color2 = colorFactory.getColor("Green");
 
      //调用 Green 的 fill 方法
      color2.fill();
 
      //获取颜色为 Blue 的对象
      Color color3 = colorFactory.getColor("BLUE");
 
      //调用 Blue 的 fill 方法
      color3.fill();
   }
}
步骤 9
执行程序，输出结果：

Inside Circle::draw() method.
Inside Rectangle::draw() metshod.
Inside Square::draw() method.
Inside Red::fill() method.
Inside Green::fill() method.
Inside Blue::fill() method.

```

原型模式(prototype pattern)
原型模式是一种创建型模式，他通过赋值一个已经存在的实例来返回新的实例，而不是新建实例。被复制的实例就是我们所称的原型。这个原型是可定制的。

原型模式的赋值分为浅拷贝和深拷贝，顺便来复习下深拷贝和浅拷贝吧。

浅拷贝: 对值类型的成员变量进行值的复制,对引用类型的成员变量只复制引用,不复制引用的对象，当修改该副本内的引用类型的变量时，会影响原来的类。

深拷贝: 对值类型的成员变量进行值的复制,对引用类型的成员变量也进行引用对象的复制，对于副本的修改，不会影响到源对象本身。

Java中的clone()方法

(1)clone()方法将对象复制了一份并返回给调用者。一般而言，clone()方法满足下面规范：

①对任何的对象x，都有x.clone() != x;//克隆对象与原对象不是同一个对象

②对任何的对象x，都有x.clone().getClass()== x.getClass();//克隆对象与原对象的类型一样

③如果对象x的equals()方法定义恰当，那么x.clone().equals(x);应该成立。

那么我们来看看浅拷贝的实现和深拷贝的实现。Java中Object自带一个clone（）方法，但是这个方法是浅拷贝的，为了实现深拷贝，必须让对应的类内对象成员变量（即这个类内部的引用类型的成员变量）实现cloneable接口，重写clone方法。

先看一下如何实现浅拷贝

//Professor没有实现Cloneable接口，默认使用java.lang.Object类的clone()方法 

class Professor{ 

    String name; 

    int age; 

    Professor(String name,int age){ 

        this.name=name; 

        this.age=age; 

    } 

} 

//Student实现了Cloneable接口 

class Student implements Cloneable{ 

    String name;//常量对象。 

    int age; 

    Professor p; 

    Student(String name,int age,Professor p){ 

        this.name=name; 

        this.age=age; 

        this.p=p; 

    } 

    public Object clone(){ 

        Student o=null; 

        try{ 

            o=(Student)super.clone(); 

        }catch(CloneNotSupportedException e){ 

            System.out.println(e.toString()); 

        } 

    //使用Object类的clone()方法 

        o.p=(Professor)this.p.clone(); 

        return o; 

    } 

} 

public static void main(String[] args){ 

      Professor p=new Professor("wangwu",50); 

      Student s1=new Student("zhangsan",18,p); 

      Student s2=(Student)s1.clone(); 

      s2.p.name="lisi"; 

      s2.p.age=30; 

   //学生1的教授也变成了lisi,age为30 

   System.out.println("name="+s1.p.name+","+"age="+s1.p.age);  

} 

 

我们来看个例子，我把我的代码复制过来，看一下如何实现深拷贝(ArrayList也可以深拷贝)。

package prototype;

 

public class Teacher implements Cloneable{

       String name;

       String id;

       public Teacher(String name, String id) {

              super();

              this.name = name;

              this.id = id;

       }

      

       @Override

       protected Object clone(){

              // TODO Auto-generated method stub

              Object o=null;

              try{

                     o=super.clone();

              }catch(Exception e){

                     e.printStackTrace();

              }

              return o;

       }

 

}

 

public class Element implements Cloneable{

      

       String name;

 

       public Element(String name) {

              super();

              this.name = name;

       }

      

       @Override

       protected Object clone(){

              // TODO Auto-generated method stub

              Object o = null;

              try{

                     o=super.clone();

                    

              }catch(Exception e){

                     e.printStackTrace();

              }

             

              return o;

       }

      

       public String toString(){

              return name+ "　";

       }

 

}

 

package prototype;

 

import java.util.ArrayList;

 

public class Student implements Cloneable{

      

       String name;

       String id;

       Teacher tea;

       ArrayList<Element> e = new  ArrayList<>();

      

       public Student(String name,String id,Teacher tea){

              this.id=id;

              this.name=name;

              this.tea=tea;

       }

      

       @Override

       protected Object clone() {

              // TODO Auto-generated method stub

              Student s = null;

              try{

                     s=(Student)super.clone();

                     s.tea=(Teacher)this.tea.clone();

                     ArrayList<Element> newE = new ArrayList<>();

                     for(Element ele:e){

                            Element e = (Element) ele.clone();

                            newE.add(e);

                     }

                     s.e=newE;

              }catch(Exception e){

                    

              }

             

              return s;

       }

      

       public static void main(String[] args){

              Student s1 = new Student("liming", "001", new Teacher("Li","100"));

              Element e1 = new Element("e1");

              Element e2 = new Element("e2");

              Element e3 = new Element("e3");

              s1.e.add(e1);

              s1.e.add(e2);

              s1.e.add(e3);

             

              Student s2 = (Student) s1.clone();

              s2.tea.name="xiaohua";

              for(Element ele:s2.e){

                     ele.name="a";

              }

             

              System.out.println(s1.tea.name+" "+s1.e);

              System.out.println(s2.tea.name+" "+s2.e);

       }

}

 

单例模式(Singleton pattern)
饿汉模式的单例是线程安全的：


静态内部类也是线程安全的

多例模式(Multition pattern)
多例模式可以看做是单例模式的推广，作为对象的创建模式，多例模式或多例类有如下特点：

（1）多例类可有多个实例

（2）多例类必须自己创建、管理自己的实例，并向外界提供自己的实例。

（3）根据是否有实例上限分为：有上限多例类和无上限多例类。

多例模式就是在一个类里面一次性的创建多个实例，并将实例添加到一个list或者map中，然后获取你想要的实例就可以了。比如语言的多例模式，如下所示：

import java.util.*;

class LingualResource

{

    private String languages = "en";

    private String region = "US";

    private String localeCode = "en_US";

    private static final String FILE_NAME = "res";

    private static Map<String,LingualResource> instances = new HashMap< String,LingualResource >();

    private Locale locale = null;

    private ResourceBundle resourceBundle = null;

    private LingualResource lingualResource;

 

    private LingualResource(String language,String region)

    {

        this.localeCode = language;

        this.region = region;

        localeCode = makeLocaleCode(language,region);

        locale = new Locale(language,region);

        resourceBundle = ResourceBundle.getBundle(FILE_NAME,locale);

        instances.put(localeCode,this);

    }

    private LingualResource() {}

 

    public synchronized static LingualResource getInstance(String language,String region)

    {

        if(instances.get(makeLocaleCode(language,region)) != null)

        {

            return instances.get(makeLocaleCode(language,region));

        } else {

            return new LingualResource(language,region);

        }

    }

    public String getLocaleString(String code)

    {

        return resourceBundle.getString(code);

    }

    private static String makeLocaleCode(String language,String region)

    {

        return language + "_" + region;

    }

}

 

class LingualResourceTest

{

    public static void main(String[] args)

    {

        LingualResource lr = LingualResource.getInstance("en","US");

        String usDollar = lr.getLocaleString("USD");

        System.out.println("USD=" + usDollar);

    }

}

将不同地区的语言和对应的地区进行封装，创建多个实例，来实现多例模式

结构型模式
适配器模式(Adapter pattern)
将一个类的接口转换成客户希望的另外一个接口，Adapter模式使得原本由于接口不兼容而不能一起工作的类可以在一起工作。适配器模式通过使用继承（实现）和组合，分为两种，分别是类适配器模式和对象适配器模式。

类适配器模式：

上图可以看出，Adaptee没有sampleOperation2方法，而客户端期望使用这个方法，于是我们使用Adapter继承Adaptee，并实现Target接口。图上没有画出来的是Client类，这个类持有一个Target类型的变量，只要将这个变量初始化为对应的Adapter，即可使用Adaptee的方法。

对象适配器方法

和前面的功能是异曲同工的，只不过继承改成了组合。Adapter持有Adaptee的对象，用这个对象来实现对应的sampleOperation1或者sampleOperation2方法。和前面相比，前面的类适配器不需要重写sampleOperation1方法，因为通过继承获得了Adaptee的对应的方法。

桥接模式(Bridge pattern)
桥接模式的目的是把变化的部分抽象出来，使得变化部分与主类分离开来，从而将多个维度的变化彻底分离。桥接模式常常应用于多个维度变化的类（即一个类变化的原因多于1个）。

桥接模式的类图如下：

当变化的维度超过1个的时候，可以将多余1个的维度拿出来作为抽象的类。上图的Implementor就是一个多余的变化维度，将这个维度的变化的可能抽象，具体的实现通过实现这个抽象接口的方式来实现（如图中的Implementor和ConcreteImplementorA/B）。然后Abstraction也是一个变化的维度，因此它也是抽象的。这个维度持有Implementor抽象接口的一个成员变量，通过初始化不同的实际成员来实现所需的功能。Abstraction变化的维度被封装到了外面，内部由于是抽象，抽象是稳定的。如果有更多的维度，那么就让Abstraction持有更多的抽象类型对象即可。

下图介绍了一个简单的例子。汽车有小汽车和公交车，道路有高速路和城市公路，那么这就是两个变化的维度，我们让AbstractRoad作为上面类图的Abstraction，AbstractCar作为Implementor，看一下实现的过程

abstract class AbstractRoad{ 

    AbstractCar aCar; 

    void run(){}; 

} 

abstract class AbstractCar{ 

    void run(){}; 

} 

 

class Street extends AbstractRoad{ 

    @Override 

    void run() { 

        // TODO Auto-generated method stub 

        super.run(); 

        aCar.run(); 

        System.out.println("在市区街道行驶"); 

    } 

} 

class SpeedWay extends AbstractRoad{ 

    @Override 

    void run() { 

        // TODO Auto-generated method stub 

        super.run(); 

        aCar.run(); 

        System.out.println("在高速公路行驶"); 

    } 

} 

class Car extends AbstractCar{ 

    @Override 

    void run() { 

        // TODO Auto-generated method stub 

        super.run(); 

        System.out.print("小汽车"); 

    } 

} 

class Bus extends AbstractCar{ 

    @Override 

    void run() { 

        // TODO Auto-generated method stub 

        super.run(); 

        System.out.print("公交车"); 

    } 

} 

 

public static void main(String[] args){ 

     

    AbstractRoad speedWay = new SpeedWay(); 

    speedWay.aCar = new Car(); 

    speedWay.run(); 

     

    AbstractRoad street = new Street(); 

    street.aCar = new Bus(); 

    street.run(); 

 

组合模式(composite pattern)

组合模式是一个很有意思的模式。最常见的可以适合组合模式的就是文件目录。比如linux的文件系统，/根目录下有若干的目录，每个目录下面又有若干的目录，到最后目录下面会有文件或者目录或者是空的文件夹。那么根目录/就是图中的Component，目录（文件夹）就是图中的composite，文件就是图中的Leaf。这样是不是就很容易理解了？这些类都实现了图中抽象类Component的方法，只不过有的方法有具体的实现代码，有的仅仅是“System.out.println(“Sorry，this object can not implement thismethod”)””。下面看个例子：

package Composite;

//Component ,抽象文件类

/**

 * Created by Jiqing on 2016/10/5.

 */

abstract class AbstractFile {

    public abstract void add(AbstractFile file);

    public abstract void remove(AbstractFile file);

    public abstract AbstractFile getChild(int i);

    public abstract void killVirus();

}

 

package Composite;

//图片文件类，一个具体的叶子Leaf

/**

 * Created by Jiqing on 2016/10/5.

 */

public class ImageFile extends AbstractFile{

    private String name;

    public ImageFile (String name) {

        this.name = name;

    }

    public void add(AbstractFile file) {

        System.out.println("对不起，不支持该方法！");

    }

    public void remove(AbstractFile file) {

        System.out.println("对不起，不支持该方法！");

    }

    public AbstractFile getChild(int i) {

        System.out.println("对不起，不支持该方法！");

        return null;

    }

    public void killVirus() {

        // 模拟杀毒

        System.out.println("----对图像文件'" + name + "'进行杀毒----");

    }

}

 

package Composite;

//文本文件，一个Leaf

/**

 * Created by Jiqing on 2016/10/5.

 */

public class TextFile extends AbstractFile{

    private String name;

    public TextFile (String name) {

        this.name = name;

    }

    public void add(AbstractFile file) {

        System.out.println("对不起，不支持该方法！");

    }

    public void remove(AbstractFile file) {

        System.out.println("对不起，不支持该方法！");

    }

    public AbstractFile getChild(int i) {

        System.out.println("对不起，不支持该方法！");

        return null;

    }

    public void killVirus() {

        // 模拟杀毒

        System.out.println("----对文本文件'" + name + "'进行杀毒----");

    }

}

 

package Composite;

 

import java.util.ArrayList;

//文件夹类，一个composite

/**

 * Created by Jiqing on 2016/10/5.

 */

public class Folder extends AbstractFile{

    private ArrayList<AbstractFile> fileList = new ArrayList<AbstractFile>(); // 规定集合中成员类型

    private String name;

    public Folder(String name) {

        this.name = name;

    }

 

    public void add(AbstractFile file) {

        fileList.add(file);

    }

 

    public void remove(AbstractFile file) {

        fileList.remove(file);

    }

 

    public AbstractFile getChild(int i) {

        return (AbstractFile)fileList.get(i); // 强制转换为类型

    }

 

    public void killVirus() {

        System.out.println("****对文件夹'" + name + "'进行杀毒****"); // 模拟杀毒

        // 递归调用成员构件的杀毒方法

        for (Object obj :fileList) {

            ((AbstractFile)obj).killVirus();

        }

    }

}

 

package Composite;

 

/**

 * Created by Jiqing on 2016/10/5.

 */

public class Client {

    public static void main(String args[]) {

        AbstractFile file1,file2,file3,file4,file5,folder1,folder2,folder3,folder4;

        folder1 = new Folder("Jim的资料");

        folder2 = new Folder("图像文件");

        folder3 = new Folder("文本文件");

        folder4 = new Folder("视频文件");

 

        file1 = new ImageFile("小龙女.jpg");

        file2 = new ImageFile("张无忌.gif");

        file3 = new TextFile("九阴真经.txt");

        file4 = new TextFile("葵花宝典.doc");

        file5 = new VideoFile("笑傲江湖.rmvb");

 

        folder2.add(file1);

        folder2.add(file2);

        folder3.add(file3);

        folder3.add(file4);

        folder4.add(file5);

        folder1.add(folder2);

        folder1.add(folder3);

        folder1.add(folder4);

 

        folder1.killVirus();

    }

}

 

装饰者模式(decorator pattern)
装饰者模式通过动态的给一个类添加一些额外的职责（就像给他添加一些装饰品一样），使用Decorator比使用子类的方式要更灵活一些。

这个类图的含义是：Component是要被装饰的抽象类，ConcreteComponent是一个具体的类。Decorator是一个抽象的装饰器类，装饰器类下面又有若干的具体的装饰器。这个的实现也比较有意思。关键是Decorator持有一个Component对象，通过这个Component对象，我们可以不断的给Component增加装饰。比如下面的例子。

 package com.test.patten.decorator;

//Component类

 public interface Person {

   void doCoding();

}

 

package com.test.patten.decorator;

 

public class Employee implements Person {

    @Override

    public void doCoding() {

        System.out.println("程序员加班写程序啊，写程序，终于写完了。。。");

    }

}

 

package com.test.patten.decorator;

//抽象装饰器类

public abstract class Manager implements Person{

      //装饰器增加功能

    public abstract void doCoding();

}

 

package com.test.patten.decorator;

//一个具体的装饰器

public class ManagerA extends Manager {

    private Person person;//给雇员升职

    public ManagerA(Person person) {

        super();

        this.person = person;

    }

    @Override

    public void doCoding() {

        doEarlyWork();

        person.doCoding();       

    }

    /**

     * 项目经理开始前期准备工作

     */

    public void doEarlyWork() {

        System.out.println("项目经理A做需求分析");

        System.out.println("项目经理A做架构设计");

        System.out.println("项目经理A做详细设计");

    }

}

 

package com.test.patten.decorator;

//另一个具体的装饰器

public class ManagerB extends Manager {

    private Person person;//给雇员升职

   

    public ManagerB(Person person) {

        super();

        this.person = person;

    }

    @Override

    public void doCoding() {

        person.doCoding();

        doEndWork();

    }

    /**

     * 项目经理开始项目收尾工作

     */

    public void doEndWork() {

        System.out.println("项目经理B 在做收尾工作");

    }

}

 

package com.test.patten.decorator;

//main方法，多次装饰Employee，让Employee变得无比强大

public class Client {

    public static void main(String args[]){

        Person employee = new Employee();

        employee = new ManagerA(employee);//赋予程序猿项目经理A职责

        employee = new ManagerB(employee);//赋予程序猿项目经理B职责

        employee.doCoding();

    }

}

//输出

项目经理A做需求分析

项目经理A做架构设计

项目经理A做详细设计

程序员加班写程序啊，写程序，终于写完了。。。

项目经理B 在做收尾工作

 

外观模式(facade pattern)
外观模式是一个比较简单的模式。它的作用是将系统内部的实现隐藏，只对外提供一系列可以访问的接口，提高安全性和可用性。

亨元模式(Flyweight Pattern)
享元模式Flyweight，在拳击比赛指最轻量级。这样起名字是这样最能表达享元模式的用意。享元模式以共享的模式高效的支持大量的细粒度对象。具体来说就是：如果一个系统中存在着大量相同的对象，那么只需要共享一份对象的拷贝，而不必为每一次使用创建新的对象。享元模式一般和单例模式一起结合使用。

Flyweight：抽象享元角色，给出一个抽象接口，以规定所有的具体享元角色需要实现的方法。

ConcreteFlyweight：具体的享元对象，必须是共享的，需要封装Flyweight的内部状态。

UnsharedConcreteFlyweight：有的还有一个这个具体类，继承自Flyweight，这是非共享的享元对象。

FlyweightFactory：享元工厂，主要用来创建并管理共享的享元对象，对外提供访问享元的接口。

下面我们来看一个具体的例子。

public interface Flyweight {

    //一个示意性方法，参数state是外蕴状态

    public void operation(String state);

}

public class ConcreteFlyweight implements Flyweight {

    private Character intrinsicState = null;

    /**

     * 构造函数，内蕴状态作为参数传入

     * @param state

     */

    public ConcreteFlyweight(Character state){

        this.intrinsicState = state;

    }

    /**

     * 外蕴状态作为参数传入方法中，改变方法的行为，

     * 但是并不改变对象的内蕴状态。

     */

    @Override

    public void operation(String state) {

        // TODO Auto-generated method stub

        System.out.println("Intrinsic State = " + this.intrinsicState);

        System.out.println("Extrinsic State = " + state);

    }

}

享元工厂类，由于这个类一般只有一个，因此这里可以使用单例模式。

public class FlyweightFactory {

    private Map<Character,Flyweight> files = new HashMap<Character,Flyweight>();

    public Flyweight factory(Character state){

        //先从缓存中查找对象

        Flyweight fly = files.get(state);

        if(fly == null){

            //如果对象不存在则创建一个新的Flyweight对象

            fly = new ConcreteFlyweight(state);

            //把这个新的Flyweight对象添加到缓存中

            files.put(state, fly);

        }

        return fly;

    }

}

客户端类

public class Client {

 

    public static void main(String[] args) {

        // TODO Auto-generated method stub

        FlyweightFactory factory = new FlyweightFactory();

        Flyweight fly = factory.factory(new Character('a'));

        fly.operation("First Call");

       

        fly = factory.factory(new Character('b'));

        fly.operation("Second Call");

       

        fly = factory.factory(new Character('a'));

        fly.operation("Third Call");

    }

 

}

 

代理模式(Proxy pattern)
代理模式一般是用来进行远程调用的。比如客户端需要远程调用服务器的功能，可以使用代理模式将所需要的功能让代理传递给我们的客户端，通过调用这个代理的函数，看上去就像直接调用这个服务器的功能一样。这种常见的代理模式的应用有RMI。

还有的代理呢，使用的目的是为了给被代理对象添加新的功能，增加一些新的处理。比如java 的动态代理Proxy。

动态代理Proxy

这个代理的实现由2步，第一步，让一个类实现InvocationHandler接口并实现invoke方法。第二步，使用Proxy的静态方法newProxyInstance方法创建一个实例，这个实例就是我们的代理。我们来看一个具体的例子；

public interface Subject  

{  

  public void doSomething();  

}  

public class RealSubject implements Subject  

{  

  public void doSomething()  

  {  

    System.out.println( "call doSomething()" );  

  }  

}  

public class ProxyHandler implements InvocationHandler  

{  

  private Object proxied;  

    

  public ProxyHandler( Object proxied )  

  {  

    this.proxied = proxied;  

  }  

    

  public Object invoke( Object proxy, Method method, Object[] args ) throws Throwable  

  {  

    //在转调具体目标对象之前，可以执行一些功能处理

 

    //转调具体目标对象的方法

    return method.invoke( proxied, args); 

    //在转调具体目标对象之后，可以执行一些功能处理

  }   

}

 

import java.lang.reflect.InvocationHandler;  

import java.lang.reflect.Method;  

import java.lang.reflect.Proxy;  

import sun.misc.ProxyGenerator;  

import java.io.*;  

public class DynamicProxy  

{  

  public static void main( String args[] )  

  {  

    RealSubject real = new RealSubject();  

    Subject proxySubject = (Subject)Proxy.newProxyInstance(Subject.class.getClassLoader(),

     new Class[]{Subject.class},

     new ProxyHandler(real));

        

    proxySubject.doSomething();

  

    //write proxySubject class binary data to file  

    createProxyClassFile();  

  }  

    

  public static void createProxyClassFile()  

  {  

    String name = "ProxySubject";  

    byte[] data = ProxyGenerator.generateProxyClass( name, new Class[] { Subject.class } );  

    try 

    {  

      FileOutputStream out = new FileOutputStream( name + ".class" );  

      out.write( data );  

      out.close();  

    }  

    catch( Exception e )  

    {  

      e.printStackTrace();  

    }  

  }  

}

动态代理的本质是生成一个类，这个类继承Proxy并实现Subject，从而可以进行多态开发和代理。http://www.cnblogs.com/flyoung2008/archive/2013/08/11/3251148.html

 

行为型模型
责任链模式(Chain of responsibility pattern)
责任链模式是一种对象的行为模式。在责任链模式里，很多对象由每一个对象对其下家的引用而连接起来形成一条链。请求在这个链上传递，直到链上的某一个对象决定处理此请求。发出这个请求的客户端并不知道链上的哪一个对象最终处理这个请求，这使得系统可以在不影响客户端的情况下动态地重新组织和分配责任。

在以下条件下可考虑使用Chain of Responsibility：

1 有多个的对象可以处理一个请求，哪个对象处理该请求运行时刻自动确定。

2 你想在不明确指定接受者的情况下，想过个对象中的一个提交一个请求。

3 可处理一个请求的对象集合应该被动态指定。

这里可以举一个简单的例子，比如项目经理报销额度不能大于500，部门经理不能大于1000，超过1000需要总经理审核。也就是说，这个可以用调用链来处理。下面来看代吗

abstract class ConsumeHandler {

 

    private ConsumeHandler nextHandler;

 

    public ConsumeHandler getNextHandler() {

        return nextHandler;

    }

 

    public void setNextHandler(ConsumeHandler nextHandler) {

        this.nextHandler = nextHandler;

    }

 

    /** user申请人 free报销费用 */

    public abstract void doHandler(String user, double free);

 

}

//项目经理

class ProjectHandler extends ConsumeHandler {

 

    @Override

    public void doHandler(String user, double free) {

        if (free < 500) {

 

            if (user.equals("lwx")) {

                System.out.println("给予报销:" + free);

            } else {

                System.out.println("报销不通过");

            }

 

        } else {

            if (getNextHandler() != null) {

 

                getNextHandler().doHandler(user, free);

            }

        }

 

    }

}

//部门经理

class DeptHandler extends ConsumeHandler {

   

    @Override

    public void doHandler(String user, double free) {

        if (free < 1000) {

           

            if (user.equals("zy")) {

                System.out.println("给予报销:" + free);

            } else {

                System.out.println("报销不通过");

            }

           

        } else {

            if (getNextHandler() != null) {

               

                getNextHandler().doHandler(user, free);

            }

        }

       

    }

}

//总经理

class GeneralHandler extends ConsumeHandler {

   

    @Override

    public void doHandler(String user, double free) {

        if (free >=1000) {

           

            if (user.equals("lwxzy")) {

                System.out.println("给予报销:" + free);

            } else {

                System.out.println("报销不通过");

            }

           

        } else {

            if (getNextHandler() != null) {

               

                getNextHandler().doHandler(user, free);

            }

        }

       

    }

}

测试下

public static void main(String[] args) {

 

        /*ConcreteHandler handler1 = new ConcreteHandler();

        ConcreteHandler handler2 = new ConcreteHandler();

        handler1.setNextHandler(handler2);

        handler1.doHandler();*/

       

        ProjectHandler projectHandler =new ProjectHandler();

        DeptHandler deptHandler =new DeptHandler();

        GeneralHandler generalHandler =new GeneralHandler();

        projectHandler.setNextHandler(deptHandler);

        deptHandler.setNextHandler(generalHandler);

        projectHandler.doHandler("lwx", 450);

        projectHandler.doHandler("lwx", 600);

        projectHandler.doHandler("zy", 600);

        projectHandler.doHandler("zy", 1500);

        projectHandler.doHandler("lwxzy", 1500);

    }

 

命令模式(Command pattern)
命令模式可以将一个请求封装为一个对象（即Command）对象，从而使你可以使用不同的请求来对客户进行参数化；对请求排队或记录请求日志，以及支持可撤销的操作。

ICommand：抽象命令，定义命令的接口

ConcreteCommand：具体命令，实现要执行的方法。他通常会持有接受者的对象，调用接收者的方法来完成命令操作。

Receiver:接收者，真正执行命令的对象。

Invoker：调用者，要求命令对象执行请求，通常会持有命令对象。可以持有很多的命令对象，是客户端调用命令的入口。

/// <summary>

    /// 接收者类，知道如何实施与执行一个请求相关的操作，任何类都可能作为一个接收者。

    /// </summary>

    public class Receiver

    {

        /// <summary>

        /// 真正的命令实现

        /// </summary>

        public void Action()

        {

            Console.WriteLine("Execute request!");

        }

    }

 

    /// <summary>

    /// 抽象命令类，用来声明执行操作的接口

    /// </summary>

    public interface ICommand

    {

        void Execute();

    }

 

    /// <summary>

    /// 具体命令类，实现具体命令。

    /// </summary>

    public class ConcereteCommand : ICommand

    {

        // 具体命令类包含有一个接收者，将这个接收者对象绑定于一个动作

        private Receiver receiver;

 

        public ConcereteCommand(Receiver receiver)

        {

            this.receiver = receiver;

        }

 

        /// <summary>

        /// 说这个实现是“虚”的，因为它是通过调用接收者相应的操作来实现Execute的

        /// </summary>

        public void Execute()

        {

            receiver.Action();

        }

    }

 

    /// <summary>

    /// 调度类，要求该命令执行这个请求

    /// </summary>

    public class Invoker

    {

        private ICommand command;

 

        /// <summary>

        /// 设置命令

        /// </summary>

        /// <param name="command"></param>

        public void SetCommand(ICommand command)

        {

            this.command = command;

        }

 

        /// <summary>

        /// 执行命令

        /// </summary>

        public void ExecuteCommand()

        {

            command.Execute();

        }

    }

客户端代码

class Program

    {

        static void Main(string[] args)

        {

            Receiver receiver = new Receiver();

            ICommand command = new ConcereteCommand(receiver);

            Invoker invoker = new Invoker();

 

            invoker.SetCommand(command);

            invoker.ExecuteCommand();

 

            Console.Read();

        }

    }

下面来看看如何使用命令模式来实现redo和undo操作。可以通过增加一个命令管理类，所有命令的执行都通过命令管理类来执行。让所有的执行过的命令都存储在这个管理类的栈里面。

抽象命令接口

package com.xueyoucto.xueyou; 

 

/**

 * Created by Administrator on 2016-07-05.

 */ 

public interface Command { 

    public void execute(); 

    public void undo(); 

} 

具体的实现类CutCommand

package com.xueyoucto.xueyou; 

 

/**

 * Created by Administrator on 2016-07-05.

 */ 

public class CutCommand implements Command { 

    private String name; 

 

    public CutCommand(String name) { 

        this.name = name; 

    } 

 

    @Override 

    public void undo() { 

        System.out.println("command:" + name + " is undo"); 

    } 

 

    @Override 

    public void execute() { 

        System.out.println("command:" + name + " is execute"); 

    } 

} 

具体的InsertCommand类

package com.xueyoucto.xueyou; 

 

/**

 * Created by Administrator on 2016-07-05.

 */ 

public class insertCommand implements Command{ 

    private String cmdName; 

    private String id; 

    private String name; 

    private int age; 

 

    public insertCommand(String cmdName, String id, String name, int age) { 

        this.cmdName = cmdName; 

        this.id = id; 

        this.name = name; 

        this.age = age; 

    } 

 

    @Override 

    public void undo() { 

        System.out.println(cmdName + " undo"); 

        System.out.println("执行delete * from table1 where id = " +id ); 

    } 

 

    @Override 

    public void execute() { 

        System.out.println(cmdName + " execute"); 

        System.out.println("执行insert into table1(id,name,age) values(" + id + "," + name + "," + age + ")"); 

    } 

} 

命令管理类

package com.xueyoucto.xueyou; 

 

import java.util.Stack; 

 

/**

 * Created by Administrator on 2016-07-05.

 */ 

public class CommandManager { 

    private Stack<Command> undoCommand = new Stack<Command>(); 

    private Stack<Command> redoCommand = new Stack<Command>(); 

 

    public void executeCommand(Command command){ 

        command.execute(); 

        undoCommand.push(command); 

 

        if(!redoCommand.empty()){ 

            redoCommand.clear(); 

        } 

    } 

    public void undo(){ 

       if(!undoCommand.empty()){ 

           Command command = undoCommand.pop(); 

           command.undo(); 

           redoCommand.push(command); 

       } 

    } 

   public void redo(){ 

       if(!redoCommand.isEmpty()){ 

           Command command = redoCommand.pop(); 

           command.execute(); 

       } 

   } 

} 

客户端类

package com.xueyoucto.xueyou; 

 

/**

 * Hello world!

 */ 

public class App { 

    public static void main(String[] args) { 

        System.out.println("Hello World!"); 

        CommandManager commandManager = new CommandManager(); 

        commandManager.executeCommand(new CutCommand("cut")); 

        commandManager.executeCommand(new insertCommand("insert","0001","小刚",12)); 

        commandManager.undo(); 

        commandManager.undo(); 

        commandManager.redo(); 

        commandManager.redo(); 

 

    } 

} 

 

解释器模式(Interpreter pattern)
解释器模式面对的是复杂的预算模型。通常解释器是一个模型公式，通过输入参数获得你所需要的结果。

解释器模式在实际使用中较少，了解即可。

迭代器模式(iterator pattern)
迭代器模式是平常用的最多的模式，也是我平常最会用的模式，就先不写了吧。把类图放在这里吧。

中介者模式(Mediator pattern)
用一个中介者对象封装一系列的对象交互，中介者使个对象不需要显示的相互作用，从而是耦合松散，而且可以独立的改变他们之间的交互。

终结者模式的结构：

 抽象中介者：定义好同事类对象到中介者对象的接口，用于各个同事类之间的通信。一般包括一个或几个抽象的事件方法，并由子类去实现。
中介者实现类：从抽象中介者继承而来，实现抽象中介者中定义的事件方法。从一个同事类接收消息，然后通过消息影响其他同时类。
同事类：如果一个对象会影响其他的对象，同时也会被其他对象影响，那么这两个对象称为同事类。在类图中，同事类只有一个，这其实是现实的省略，在实际应用中，同事类一般由多个组成，他们之间相互影响，相互依赖。同事类越多，关系越复杂。并且，同事类也可以表现为继承了同一个抽象类的一组实现组成。在中介者模式中，同事类之间必须通过中介者才能进行消息传递。
我们来看一个简单的例子，有两个类A和B，类中各有一个数字，并且要保证类B中的数字永远是类A中数字的100倍。也就是说，当修改类A的数时，将这个数字乘以100赋给类B，而修改类B时，要将数除以100赋给类A。类A类B互相影响，就称为同事类。代码如下：

abstract class AbstractColleague { 

    protected int number; 

    public int getNumber() { 

        return number; 

    } 

    public void setNumber(int number){ 

        this.number = number; 

    } 

    //抽象方法，修改数字时同时修改关联对象 

    public abstract void setNumber(int number, AbstractColleague coll); 

} 

class ColleagueA extends AbstractColleague{ 

    public void setNumber(int number, AbstractColleague coll) { 

        this.number = number; 

        coll.setNumber(number*100); 

    } 

} 

 

class ColleagueB extends AbstractColleague{ 

    public void setNumber(int number, AbstractColleague coll) { 

        this.number = number; 

        coll.setNumber(number/100); 

    } 

} 

public class Client { 

    public static void main(String[] args){ 

        AbstractColleague collA = new ColleagueA(); 

        AbstractColleague collB = new ColleagueB(); 

        System.out.println("==========设置A影响B=========="); 

        collA.setNumber(1288, collB); 

        System.out.println("collA的number值："+collA.getNumber()); 

        System.out.println("collB的number值："+collB.getNumber()); 

        System.out.println("==========设置B影响A=========="); 

        collB.setNumber(87635, collA); 

        System.out.println("collB的number值："+collB.getNumber()); 

        System.out.println("collA的number值："+collA.getNumber()); 

    } 

} 

有了中介者之后，A和B就解耦了，同时你再增加新的同事也可以满足这种模式了。同时当有多个同事的时候，比如A能影响CDEFG若干同事，现在只需要交给中介者模式去做就可以了。

abstract class AbstractColleague { 

    protected int number; 

 

    public int getNumber() { 

        return number; 

    } 

 

    public void setNumber(int number){ 

        this.number = number; 

    } 

    //注意这里的参数不再是同事类，而是一个中介者 

    public abstract void setNumber(int number, AbstractMediator am); 

} 

 

class ColleagueA extends AbstractColleague{ 

 

    public void setNumber(int number, AbstractMediator am) { 

        this.number = number; 

        am.AaffectB(); 

    } 

} 

 

class ColleagueB extends AbstractColleague{ 

 

    @Override 

    public void setNumber(int number, AbstractMediator am) { 

        this.number = number; 

        am.BaffectA(); 

    } 

} 

 

abstract class AbstractMediator { 

    protected AbstractColleague A; 

    protected AbstractColleague B; 

     

    public AbstractMediator(AbstractColleague a, AbstractColleague b) { 

        A = a; 

        B = b; 

    } 

 

    public abstract void AaffectB(); 

     

    public abstract void BaffectA(); 

 

} 

class Mediator extends AbstractMediator { 

 

    public Mediator(AbstractColleague a, AbstractColleague b) { 

        super(a, b); 

    } 

 

    //处理A对B的影响 

    public void AaffectB() { 

        int number = A.getNumber(); 

        B.setNumber(number*100); 

    } 

 

    //处理B对A的影响 

    public void BaffectA() { 

        int number = B.getNumber(); 

        A.setNumber(number/100); 

    } 

} 

 

public class Client { 

    public static void main(String[] args){ 

        AbstractColleague collA = new ColleagueA(); 

        AbstractColleague collB = new ColleagueB(); 

         

        AbstractMediator am = new Mediator(collA, collB); 

         

        System.out.println("==========通过设置A影响B=========="); 

        collA.setNumber(1000, am); 

        System.out.println("collA的number值为："+collA.getNumber()); 

        System.out.println("collB的number值为A的10倍："+collB.getNumber()); 

 

        System.out.println("==========通过设置B影响A=========="); 

        collB.setNumber(1000, am); 

        System.out.println("collB的number值为："+collB.getNumber()); 

        System.out.println("collA的number值为B的0.1倍："+collA.getNumber()); 

         

    } 

} 

 

备忘录模式(Memento pattern)
在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态。

备忘录模式可以实现恢复原来的状态，这是通过将这个状态保存到备忘录中实现的。类图的结构的含义是：

发起人：记录当前时刻的内部状态，负责定义哪些属于备份范围的状态，负责创建和恢复备忘录。

备忘录：负责存储发起人对象的内部状态，在需要的时候提供发起人的内部状态。

管理角色：对备忘录进行管理，保存和提供备忘录

class Originator { 

    private String state = ""; 

     

    public String getState() { 

        return state; 

    } 

    public void setState(String state) { 

        this.state = state; 

    } 

    public Memento createMemento(){ 

        return new Memento(this.state); 

    } 

    public void restoreMemento(Memento memento){ 

        this.setState(memento.getState()); 

    } 

} 

 

class Memento { 

    private String state = "";  

    public Memento(String state){ 

        this.state = state; 

    } 

    public String getState() { 

        return state; 

    } 

    public void setState(String state) { 

        this.state = state; 

    } 

} 

class Caretaker { 

    private Memento memento; 

    public Memento getMemento(){ 

        return memento; 

    } 

    public void setMemento(Memento memento){ 

        this.memento = memento; 

    } 

} 

public class Client { 

    public static void main(String[] args){ 

        Originator originator = new Originator(); 

        originator.setState("状态1"); 

        System.out.println("初始状态:"+originator.getState()); 

        Caretaker caretaker = new Caretaker(); 

        caretaker.setMemento(originator.createMemento()); 

        originator.setState("状态2"); 

        System.out.println("改变后状态:"+originator.getState()); 

        originator.restoreMemento(caretaker.getMemento()); 

        System.out.println("恢复后状态:"+originator.getState()); 

    } 

} 

看一个多状态多备忘录的模式

class Originator { 

    private String state1 = ""; 

    private String state2 = ""; 

    private String state3 = ""; 

 

    public String getState1() { 

        return state1; 

    } 

    public void setState1(String state1) { 

        this.state1 = state1; 

    } 

    public String getState2() { 

        return state2; 

    } 

    public void setState2(String state2) { 

        this.state2 = state2; 

    } 

    public String getState3() { 

        return state3; 

    } 

    public void setState3(String state3) { 

        this.state3 = state3; 

    } 

    public Memento createMemento(){ 

        return new Memento(BeanUtils.backupProp(this)); 

    } 

     

    public void restoreMemento(Memento memento){ 

        BeanUtils.restoreProp(this, memento.getStateMap()); 

    } 

    public String toString(){ 

        return "state1="+state1+"state2="+state2+"state3="+state3; 

    } 

} 

class Memento { 

    private Map<String, Object> stateMap; 

     

    public Memento(Map<String, Object> map){ 

        this.stateMap = map; 

    } 

 

    public Map<String, Object> getStateMap() { 

        return stateMap; 

    } 

 

    public void setStateMap(Map<String, Object> stateMap) { 

        this.stateMap = stateMap; 

    } 

} 

class BeanUtils { 

    public static Map<String, Object> backupProp(Object bean){ 

        Map<String, Object> result = new HashMap<String, Object>(); 

        try{ 

            BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass()); 

            PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors(); 

            for(PropertyDescriptor des: descriptors){ 

                String fieldName = des.getName(); 

                Method getter = des.getReadMethod(); 

                Object fieldValue = getter.invoke(bean, new Object[]{}); 

                if(!fieldName.equalsIgnoreCase("class")){ 

                    result.put(fieldName, fieldValue); 

                } 

            } 

             

        }catch(Exception e){ 

            e.printStackTrace(); 

        } 

        return result; 

    } 

     

    public static void restoreProp(Object bean, Map<String, Object> propMap){ 

        try { 

            BeanInfo beanInfo = Introspector.getBeanInfo(bean.getClass()); 

            PropertyDescriptor[] descriptors = beanInfo.getPropertyDescriptors(); 

            for(PropertyDescriptor des: descriptors){ 

                String fieldName = des.getName(); 

                if(propMap.containsKey(fieldName)){ 

                    Method setter = des.getWriteMethod(); 

                    setter.invoke(bean, new Object[]{propMap.get(fieldName)}); 

                } 

            } 

        } catch (Exception e) { 

            e.printStackTrace(); 

        } 

    } 

} 

class Caretaker { 

    private Map<String, Memento> memMap = new HashMap<String, Memento>(); 

    public Memento getMemento(String index){ 

        return memMap.get(index); 

    } 

     

    public void setMemento(String index, Memento memento){ 

        this.memMap.put(index, memento); 

    } 

} 

class Client { 

    public static void main(String[] args){ 

        Originator ori = new Originator(); 

        Caretaker caretaker = new Caretaker();  

        ori.setState1("中国"); 

        ori.setState2("强盛"); 

        ori.setState3("繁荣"); 

        System.out.println("===初始化状态===\n"+ori); 

         

        caretaker.setMemento("001",ori.createMemento()); 

        ori.setState1("软件"); 

        ori.setState2("架构"); 

        ori.setState3("优秀"); 

        System.out.println("===修改后状态===\n"+ori); 

         

        ori.restoreMemento(caretaker.getMemento("001")); 

        System.out.println("===恢复后状态===\n"+ori); 

    } 

} 

 

观察者模式(observer pattern)
我们先来看观察者模式，这个模式啊，说实话，以前考试的时候考过，我还特意留意过了，当时也学会了，但是时间久了就忘了。

观察者模式有什么用呢？它的用处之一就是通知，怎么通知呢？Subject有个Notify方法，这个方法负责通知所有的观察者。这个模式有个好处，就是一旦被观察者发生了改变，那么就可以通知观察者你也要更新数据了，特别适合气象局，真的。

先来简单的介绍观察者模式的类图结构：

Subject：一个抽象类或者接口，面向接口编程嘛，这是必须的。他就是被观察者。

ConcreteSubject：具体的被观察者的实现

Observer：观察者接口

ConcreteObserver：具体的观察者实现。

观察者模式的基本运行规则是这样的：

1.一个观察者对某个东西感兴趣了，于是它向上帝（客户端）请求，你把我绑到这上面吧，我要时时刻刻的了解它的变化（Subject的attach（）方法）；

2.这个东西发生了更新，于是通知所有的绑到它上面的观察者（Subject的notify方法）

3.观察者接收到notify方法之后，更新自己的数据（Observer的update方法）

4.某个观察者厌倦了这种一夫多妻制，他想修了自己的老公了，于是他请求上帝离婚（Detach）。

Ok，我们来看看代码实现吧

/// <summary>

    /// 抽象主题类

    /// </summary>

    public abstract class Subject

    {

        private IList<Observer> observers = new List<Observer>();

 

        /// <summary>

        /// 增加观察者

        /// </summary>

        /// <param name="observer"></param>

        public void Attach(Observer observer)

        {

            observers.Add(observer);

        }

 

        /// <summary>

        /// 移除观察者

        /// </summary>

        /// <param name="observer"></param>

        public void Detach(Observer observer)

        {

            observers.Remove(observer);

        }

 

        /// <summary>

        /// 向观察者（们）发出通知

        /// </summary>

        public void Notify()

        {

            foreach (Observer o in observers)

            {

                o.Update();

            }

        }

    }

 

    /// <summary>

    /// 抽象观察者类，为所有具体观察者定义一个接口，在得到通知时更新自己

    /// </summary>

    public abstract class Observer

    {

        public abstract void Update();

    }

 

    /// <summary>

    /// 具体观察者或具体通知者，将有关状态存入具体观察者对象；在具体主题的内部状态改变时，给所有登记过的观察者发出通知。具体主题角色通常用一个具体子类实现。

    /// </summary>

    public class ConcreteSubject : Subject

    {

        private string subjectState;

 

        /// <summary>

        /// 具体观察者的状态

        /// </summary>

        public string SubjectState

        {

            get { return subjectState; }

            set { subjectState = value; }

        }

    }

 

    /// <summary>

    /// 具体观察者，实现抽象观察者角色所要求的更新接口，已是本身状态与主题状态相协调

    /// </summary>

    public class ConcreteObserver : Observer

    {

        private string observerState;

        private string name;

        private ConcreteSubject subject;

 

        /// <summary>

        /// 具体观察者用一个具体主题来实现

        /// </summary>

        public ConcreteSubject Subject

        {

            get { return subject; }

            set { subject = value; }

        }

 

        public ConcreteObserver(ConcreteSubject subject, string name)

        {

            this.subject = subject;

            this.name = name;

        }

 

        /// <summary>

        /// 实现抽象观察者中的更新操作

        /// </summary>

        public override void Update()

        {

            observerState = subject.SubjectState;

            Console.WriteLine("The observer's state of {0} is {1}", name, observerState);

        }

    }

class Program

    {

        static void Main(string[] args)

        {

            // 具体主题角色通常用具体自来来实现

            ConcreteSubject subject = new ConcreteSubject();

 

            subject.Attach(new ConcreteObserver(subject, "Observer A"));

            subject.Attach(new ConcreteObserver(subject, "Observer B"));

            subject.Attach(new ConcreteObserver(subject, "Observer C"));

 

            subject.SubjectState = "Ready";

            subject.Notify();

 

            Console.Read();

        }

    }

 

状态模式(State pattern)
状态模式和策略模式超级像，类图都几乎一样，那么怎么区别呢？如果描述的是状态的转换，就叫状态模式，如果更偏向于不同的行为策略，那就是策略模式啦。

策略模式(strategy pattern)
模板方法模式(Template pattern)
访问者模式(visitor pattern)
封装某些作用域某种数据结构中各元素的操作，它可以在不改变数据结构的千条线定义作用于这些元素的新的方式。

先来说说类图结构

 抽象访问者：抽象类或者接口，声明访问者可以访问哪些元素，具体到程序中就是visit方法中的参数定义哪些对象是可以被访问的。
访问者：实现抽象访问者所声明的方法，它影响到访问者访问到一个类后该干什么，要做什么事情。
抽象元素类：接口或者抽象类，声明接受哪一类访问者访问，程序上是通过accept方法中的参数来定义的。抽象元素一般有两类方法，一部分是本身的业务逻辑，另外就是允许接收哪类访问者来访问。
元素类：实现抽象元素类所声明的accept方法，通常都是visitor.visit(this)，基本上已经形成一种定式了。
结构对象：一个元素的容器，一般包含一个容纳多个不同类、不同接口的容器，如List、Set、Map等，在项目中一般很少抽象出这个角色。
看到这里是不是还是不懂访问者模式到底干啥？下面的代码实现就讲了访问者模式干了啥，嫌长？没关系，我来解释一下。就是Visitor想要访问Element，这是前提。于是Visitor的visit（）方法调用了Element的一个doSomething（）方法。但是不是直接调用的，而是通过傻呢？是通过Element的accept(Visitor v)调用的。总结一下就是先实例化Element，然后实例化Visitor，然后调用Element的方法accept（Visitor v），参数是前面实例化的Visitor。然后这个accept方法会调用Visitor的visit（Element e）方法，visit方法又会调用这个Element的doSomthing 方法。真绕！！！！

代码实现

abstract class Element { 

    public abstract void accept(IVisitor visitor); 

    public abstract void doSomething(); 

} 

 

interface IVisitor { 

    public void visit(ConcreteElement1 el1); 

    public void visit(ConcreteElement2 el2); 

} 

 

class ConcreteElement1 extends Element { 

    public void doSomething(){ 

        System.out.println("这是元素1"); 

    } 

     

    public void accept(IVisitor visitor) { 

        visitor.visit(this); 

    } 

} 

 

class ConcreteElement2 extends Element { 

    public void doSomething(){ 

        System.out.println("这是元素2"); 

    } 

     

    public void accept(IVisitor visitor) { 

        visitor.visit(this); 

    } 

} 

class Visitor implements IVisitor { 

 

    public void visit(ConcreteElement1 el1) { 

        el1.doSomething(); 

    } 

     

    public void visit(ConcreteElement2 el2) { 

        el2.doSomething(); 

    } 

} 

 

class ObjectStruture { 

    public static List<Element> getList(){ 

        List<Element> list = new ArrayList<Element>(); 

        Random ran = new Random(); 

        for(int i=0; i<10; i++){ 

            int a = ran.nextInt(100); 

            if(a>50){ 

                list.add(new ConcreteElement1()); 

            }else{ 

                list.add(new ConcreteElement2()); 

            } 

        } 

        return list; 

    } 

} 

 

public class Client { 

    public static void main(String[] args){ 

        List<Element> list = ObjectStruture.getList(); 

        for(Element e: list){ 

            e.accept(new Visitor()); 

        } 

    } 

} 

 

JDK中使用的设计模式
适配器模式：
用来把一个接口转化成另一个接口。

java.util.Arrays#asList()
javax.swing.JTable(TableModel)
java.io.InputStreamReader(InputStream)
java.io.OutputStreamWriter(OutputStream)
javax.xml.bind.annotation.adapters.XmlAdapter#marshal()
javax.xml.bind.annotation.adapters.XmlAdapter#unmarshal()
桥接模式：
这个模式将抽象和抽象操作的实现进行了解耦，这样使得抽象和实现可以独立地变化。

AWT (It provides an abstraction layer which maps onto the native OS the windowing support.)
 
JDBC
 

组合模式
使得客户端看来单个对象和对象的组合是同等的。换句话说，某个类型的方法同时也接受自身类型作为参数。

javax.swing.JComponent#add(Component)
java.awt.Container#add(Component)
java.util.Map#putAll(Map)
java.util.List#addAll(Collection)
java.util.Set#addAll(Collection)
 

装饰者模式：
动态的给一个对象附加额外的功能，这也是子类的一种替代方式。可以看到，在创建一个类型的时候，同时也传入同一类型的对象。这在JDK里随处可见，你会发现它无处不在，所以下面这个列表只是一小部分。

java.io.BufferedInputStream(InputStream)
java.io.DataInputStream(InputStream)
java.io.BufferedOutputStream(OutputStream)
java.util.zip.ZipOutputStream(OutputStream)
java.util.Collections#checkedList|Map|Set|SortedSet|SortedMap
 

门面模式：
给一组组件，接口，抽象，或者子系统提供一个简单的接口。

java.lang.Class
javax.faces.webapp.FacesServlet
 

享元模式
使用缓存来加速大量小对象的访问时间。

java.lang.Integer#valueOf(int)
java.lang.Boolean#valueOf(boolean)
java.lang.Byte#valueOf(byte)
java.lang.Character#valueOf(char)
代理模式
代理模式是用一个简单的对象来代替一个复杂的或者创建耗时的对象。

java.lang.reflect.Proxy
RMI
创建模式

抽象工厂模式
抽象工厂模式提供了一个协议来生成一系列的相关或者独立的对象，而不用指定具体对象的类型。它使得应用程序能够和使用的框架的具体实现进行解耦。这在JDK或者许多框架比如Spring中都随处可见。它们也很容易识别，一个创建新对象的方法，返回的却是接口或者抽象类的，就是抽象工厂模式了。

java.util.Calendar#getInstance()
java.util.Arrays#asList()
java.util.ResourceBundle#getBundle()
java.sql.DriverManager#getConnection()
java.sql.Connection#createStatement()
java.sql.Statement#executeQuery()
java.text.NumberFormat#getInstance()
javax.xml.transform.TransformerFactory#newInstance()
建造模式(Builder)
定义了一个新的类来构建另一个类的实例，以简化复杂对象的创建。建造模式通常也使用方法链接来实现。

java.lang.StringBuilder#append()
java.lang.StringBuffer#append()
java.sql.PreparedStatement
javax.swing.GroupLayout.Group#addComponent()
工厂方法
就是一个返回具体对象的方法。

java.lang.Proxy#newProxyInstance()
java.lang.Object#toString()
java.lang.Class#newInstance()
java.lang.reflect.Array#newInstance()
java.lang.reflect.Constructor#newInstance()
java.lang.Boolean#valueOf(String)
java.lang.Class#forName()
原型模式
使得类的实例能够生成自身的拷贝。如果创建一个对象的实例非常复杂且耗时时，就可以使用这种模式，而不重新创建一个新的实例，你可以拷贝一个对象并直接修改它。

java.lang.Object#clone()
java.lang.Cloneable
单例模式
用来确保类只有一个实例。Joshua Bloch在Effetive Java中建议到，还有一种方法就是使用枚举。

java.lang.Runtime#getRuntime()
java.awt.Toolkit#getDefaultToolkit()
java.awt.GraphicsEnvironment#getLocalGraphicsEnvironment()
java.awt.Desktop#getDesktop()
行为模式

责任链模式
通过把请求从一个对象传递到链条中下一个对象的方式，直到请求被处理完毕，以实现对象间的解耦。

java.util.logging.Logger#log()
javax.servlet.Filter#doFilter()
命令模式
将操作封装到对象内，以便存储，传递和返回。

java.lang.Runnable
javax.swing.Action
解释器模式
这个模式通常定义了一个语言的语法，然后解析相应语法的语句。

java.util.Pattern
java.text.Normalizer
java.text.Format
迭代器模式
提供一个一致的方法来顺序访问集合中的对象，这个方法与底层的集合的具体实现无关。

java.util.Iterator
java.util.Enumeration
中介者模式
通过使用一个中间对象来进行消息分发以及减少类之间的直接依赖。

java.util.Timer
java.util.concurrent.Executor#execute()
java.util.concurrent.ExecutorService#submit()
java.lang.reflect.Method#invoke()
备忘录模式
生成对象状态的一个快照，以便对象可以恢复原始状态而不用暴露自身的内容。Date对象通过自身内部的一个long值来实现备忘录模式。

java.util.Date
java.io.Serializable
空对象模式
这个模式通过一个无意义的对象来代替没有对象这个状态。它使得你不用额外对空对象进行处理。

java.util.Collections#emptyList()
java.util.Collections#emptyMap()
java.util.Collections#emptySet()
观察者模式
它使得一个对象可以灵活的将消息发送给感兴趣的对象。

java.util.EventListener
javax.servlet.http.HttpSessionBindingListener
javax.servlet.http.HttpSessionAttributeListener
javax.faces.event.PhaseListener
 

状态模式
通过改变对象内部的状态，使得你可以在运行时动态改变一个对象的行为。

java.util.Iterator
javax.faces.lifecycle.LifeCycle#execute()
策略模式
使用这个模式来将一组算法封装成一系列对象。通过传递这些对象可以灵活的改变程序的功能。

java.util.Comparator#compare()
javax.servlet.http.HttpServlet
javax.servlet.Filter#doFilter()
模板方法模式
让子类可以重写方法的一部分，而不是整个重写，你可以控制子类需要重写那些操作。

java.util.Collections#sort()
java.io.InputStream#skip()
java.io.InputStream#read()
java.util.AbstractList#indexOf()
访问者模式
提供一个方便的可维护的方式来操作一组对象。它使得你在不改变操作的对象前提下，可以修改或者扩展对象的行为。

javax.lang.model.element.Element and javax.lang.model.element.ElementVisitor
javax.lang.model.type.TypeMirror and javax.lang.model.type.TypeVisitor
 